from collections import deque

class Node:
    def __init__(self,state, parent, action):
        self.state = state
        self.parent = parent
        self.action = action

def bfs(start, goal):
    queue = deque([Node(start, None, None)])
    visited = {str(start)}
    while queue:
        node = queue.popleft()
        if node.state == goal:
            return node
        for child, action in expand(node):
            if str(child) not in visited:
                queue.append(Node(child, node, action))
                visited.add(str(child))
    return None

def expand(node):
    children = []
    x, y = find_blank(node.state)
    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        child_x, child_y = x + dx, y + dy
        if 0 <= child_x < len(node.state) and 0 <= child_y < len(node.state[0]):
            child_state = [row[:] for row in node.state]
            child_state[x][y], child_state[child_x][child_y] = child_state[child_x][child_y], child_state[x][y]
            children.append((child_state, (child_x, child_y)))
    return children

def find_blank(state):
    for i in range(len(state)):
        for j in range(len(state[i])):
            if state[i][j] == 0:
                return i, j

def print_grid(state):
    for row in state:
        print(row)

# Example usage
start = [[2, 8, 3], [1, 6, 4], [7, 0, 5]]
goal = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]

result = bfs(start, goal)

if result:
    path = []
    node = result
    while node:
        path.append(node.action)
        node = node.parent
    path = path[::-1]
    print("Moves:", path)
    print("Start Grid:")
    print_grid(start)
    print("Final Grid:")
    print_grid(goal)
else:
    print("No solution found")
